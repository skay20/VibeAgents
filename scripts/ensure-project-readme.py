#!/usr/bin/env python3
# Managed-By: AgenticRepoBuilder
# Template-Source: templates/scripts/ensure-project-readme.py
# Template-Version: 1.0.0
# Last-Generated: 2026-02-07T00:00:00Z
# Ownership: Managed

from __future__ import annotations

import argparse
import json
import os
import re
import subprocess
from datetime import datetime, timezone
from pathlib import Path

BEGIN = "<!-- BEGIN_MANAGED:AGENTIC_PROJECT_README -->"
END = "<!-- END_MANAGED:AGENTIC_PROJECT_README -->"


def _now_iso() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")


def _read_settings(repo_root: Path) -> dict:
    return json.loads((repo_root / ".agentic" / "settings.json").read_text(encoding="utf-8"))


def _resolve_project_root_rel(repo_root: Path, run_id: str) -> str:
    cmd = ["python3", str(repo_root / "scripts" / "resolve-project-root.py"), run_id, "--print-relative", "--write-artifact"]
    out = subprocess.check_output(cmd, cwd=str(repo_root), text=True).strip()
    return out


def _get_project_name(project_root: Path) -> str:
    pkg = project_root / "package.json"
    if pkg.exists():
        try:
            payload = json.loads(pkg.read_text(encoding="utf-8"))
            name = payload.get("name")
            if isinstance(name, str) and name.strip():
                return name.strip()
        except Exception:
            pass
    return project_root.name


def _extract_prd_summary(repo_root: Path) -> str:
    prd = repo_root / "docs" / "PRD.md"
    if not prd.exists():
        return ""
    text = prd.read_text(encoding="utf-8")
    # Prefer a "0) Resumen ejecutivo" style section if present, otherwise first non-empty paragraph.
    m = re.search(r"^0\)\s+Resumen ejecutivo\s*$", text, re.IGNORECASE | re.MULTILINE)
    if m:
        after = text[m.end() :]
        # Take up to ~20 lines until next numbered section.
        lines = []
        for line in after.splitlines():
            if re.match(r"^\s*\d+\)\s+", line):
                break
            if line.strip():
                lines.append(line.rstrip())
            if len(lines) >= 20:
                break
        return "\n".join(lines).strip()
    for para in re.split(r"\n\s*\n", text):
        p = para.strip()
        if p and "Managed-By" not in p:
            return p[:800]
    return ""


def _render_managed_block(project_name: str, project_root_rel: str, runbook_rel: str | None, prd_summary: str) -> str:
    lines: list[str] = []
    lines.append(BEGIN)
    lines.append(f"# {project_name}")
    lines.append("")
    lines.append(f"- Last updated: `{_now_iso()}`")
    lines.append(f"- Project root: `{project_root_rel}`")
    if prd_summary:
        lines.append("")
        lines.append("## Summary")
        lines.append(prd_summary)
    lines.append("")
    lines.append("## How To Run")
    lines.append(f"- `cd {project_root_rel}`")
    if runbook_rel:
        lines.append(f"- See `{runbook_rel}` for exact commands (install/dev/build/test).")
    else:
        lines.append("- See `RUNBOOK.md` for exact commands (install/dev/build/test).")
    lines.append(END)
    lines.append("")
    return "\n".join(lines)


def _upsert_managed_block(existing: str, block: str) -> str:
    if BEGIN in existing and END in existing:
        before = existing.split(BEGIN)[0].rstrip() + "\n\n"
        after = existing.split(END, 1)[1].lstrip()
        return before + block + "\n" + after
    # Append at end with a spacer.
    existing = existing.rstrip() + "\n\n"
    return existing + block


def main() -> int:
    ap = argparse.ArgumentParser(description="Ensure generated project README.md has an up-to-date managed block.")
    ap.add_argument("run_id")
    ap.add_argument("--repo-root", default=".")
    args = ap.parse_args()

    repo_root = Path(args.repo_root).resolve()
    run_id = args.run_id
    art_dir = repo_root / ".agentic" / "bus" / "artifacts" / run_id
    art_dir.mkdir(parents=True, exist_ok=True)

    settings = _read_settings(repo_root).get("settings", {})
    docs_cfg = settings.get("docs", {})

    project_root_rel = _resolve_project_root_rel(repo_root, run_id)
    if not project_root_rel:
        (art_dir / "project_readme_path.txt").write_text("\n", encoding="utf-8")
        print("[SKIP] No generated project root detected from metrics outputs_written.")
        return 0

    project_root = (repo_root / project_root_rel).resolve()
    if not project_root.exists():
        raise SystemExit(f"[FAIL] Resolved project_root does not exist: {project_root_rel}")

    template = docs_cfg.get("project_readme_path", "<project_root>/README.md")
    readme_rel = template.replace("<project_root>", project_root_rel).lstrip("./")
    readme_path = (repo_root / readme_rel).resolve()
    readme_path.parent.mkdir(parents=True, exist_ok=True)

    # Link runbook if present (generated by ensure-project-runbook).
    runbook_template = docs_cfg.get("project_runbook_path", "<project_root>/RUNBOOK.md")
    runbook_rel = runbook_template.replace("<project_root>", project_root_rel).lstrip("./")
    if not (repo_root / runbook_rel).exists():
        runbook_rel = None

    prd_summary = _extract_prd_summary(repo_root)
    project_name = _get_project_name(project_root)
    block = _render_managed_block(project_name, project_root_rel, runbook_rel, prd_summary)

    existing = readme_path.read_text(encoding="utf-8") if readme_path.exists() else ""
    updated = _upsert_managed_block(existing, block) if existing else (block + "\n")
    readme_path.write_text(updated, encoding="utf-8")

    (art_dir / "project_readme_path.txt").write_text(readme_rel + "\n", encoding="utf-8")
    print(f"[OK] Updated project README managed block: {readme_rel}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
